package oracle.jdbc.driver;

import java.io.IOException;
import java.io.InputStream;
import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.TimeZone;
import java.util.Vector;
import oracle.sql.BLOB;
import oracle.sql.CLOB;

public abstract class OracleStatement
  implements oracle.jdbc.internal.OracleStatement, ScrollRsetStatement
{
  static final int PLAIN_STMT = 0;
  static final int PREP_STMT = 1;
  static final int CALL_STMT = 2;
  static final byte IS_UNINITIALIZED = -1;
  static final byte IS_SELECT = 0;
  static final byte IS_PLSQL_BLOCK = 1;
  static final byte IS_DML = 2;
  static final byte IS_OTHER = 3;
  static final byte IS_CALL_BLOCK = 4;
  int cursorId;
  int numberOfDefinePositions;
  int definesBatchSize;
  Accessor[] accessors;
  int defineByteSubRange;
  int defineCharSubRange;
  int defineIndicatorSubRange;
  int defineLengthSubRange;
  byte[] defineBytes;
  char[] defineChars;
  short[] defineIndicators;
  boolean described = false;
  boolean describedWithNames = false;
  int rowsProcessed;
  int cachedDefineByteSize = 0;
  int cachedDefineCharSize = 0;
  int cachedDefineIndicatorSize = 0;
  OracleStatement children;
  OracleStatement nextChild;
  OracleStatement next;
  OracleStatement prev;
  long c_state;
  int numberOfBindPositions;
  byte[] bindBytes;
  char[] bindChars;
  short[] bindIndicators;
  int bindByteOffset;
  int bindCharOffset;
  int bindIndicatorOffset;
  int bindByteSubRange;
  int bindCharSubRange;
  int bindIndicatorSubRange;
  Accessor[] outBindAccessors;
  InputStream[][] parameterStream;
  int firstRowInBatch;
  boolean hasIbtBind = false;
  byte[] ibtBindBytes;
  char[] ibtBindChars;
  short[] ibtBindIndicators;
  int ibtBindByteOffset;
  int ibtBindCharOffset;
  int ibtBindIndicatorOffset;
  int ibtBindIndicatorSize;
  byte[] tmpByteArray;
  int sizeTmpByteArray = 0;
  byte[] tmpBindsByteArray;
  boolean needToSendOalToFetch = false;

  int[] definedColumnType = null;
  int[] definedColumnSize = null;
  int[] definedColumnFormOfUse = null;

  T4CTTIoac[] oacdefSent = null;

  int accessorByteOffset = 0;
  int accessorCharOffset = 0;
  int accessorShortOffset = 0;
  static final int VALID_ROWS_UNINIT = -999;
  PhysicalConnection connection;
  OracleInputStream streamList;
  OracleInputStream nextStream;
  OracleResultSetImpl currentResultSet;
  boolean processEscapes;
  boolean convertNcharLiterals;
  int queryTimeout;
  int batch;
  int currentRank;
  int currentRow;
  int validRows;
  int maxFieldSize;
  int maxRows;
  int totalRowsVisited;
  int rowPrefetch;
  int saved_rowPrefetch = -1;
  int defaultRowPrefetch;
  boolean rowPrefetchChanged;
  boolean gotLastBatch;
  boolean clearParameters;
  boolean closed;
  boolean sqlStringChanged;
  OracleSql sqlObject;
  boolean needToParse;
  boolean needToPrepareDefineBuffer;
  boolean columnsDefinedByUser;
  byte sqlKind;
  int autoRollback;
  int defaultFetchDirection;
  boolean autoRefetch;
  boolean serverCursor;
  boolean fixedString = false;

  boolean noMoreUpdateCounts = false;

  boolean isExecuting = false;
  static final byte EXECUTE_NONE = -1;
  static final byte EXECUTE_QUERY = 1;
  static final byte EXECUTE_UPDATE = 2;
  static final byte EXECUTE_NORMAL = 3;
  byte executionType = -1;
  OracleResultSet scrollRset;
  oracle.jdbc.OracleResultSetCache rsetCache;
  int userRsetType;
  int realRsetType;
  boolean needToAddIdentifier;
  SQLWarning sqlWarning;
  int cacheState = 1;

  int creationState = 0;

  boolean isOpen = false;

  int statementType = 0;

  boolean columnSetNull = false;
  int[] returnParamMeta;
  static final int DMLR_METADATA_PREFIX_SIZE = 3;
  static final int DMLR_METADATA_NUM_OF_RETURN_PARAMS = 0;
  static final int DMLR_METADATA_ROW_BIND_BYTES = 1;
  static final int DMLR_METADATA_ROW_BIND_CHARS = 2;
  static final int DMLR_METADATA_TYPE_OFFSET = 0;
  static final int DMLR_METADATA_IS_CHAR_TYPE_OFFSET = 1;
  static final int DMLR_METADATA_BIND_SIZE_OFFSET = 2;
  static final int DMLR_METADATA_PER_POSITION_SIZE = 3;
  Accessor[] returnParamAccessors;
  boolean returnParamsFetched;
  int rowsDmlReturned;
  int numReturnParams;
  byte[] returnParamBytes;
  char[] returnParamChars;
  short[] returnParamIndicators;
  int returnParamRowBytes;
  int returnParamRowChars;
  OracleReturnResultSet returnResultSet;
  boolean isAutoGeneratedKey;
  AutoKeyInfo autoKeyInfo;
  TimeZone defaultTZ = null;
  int lastIndex;
  Vector m_batchItems = new Vector();

  ArrayList tempClobsToFree = null;
  ArrayList tempBlobsToFree = null;

  ArrayList oldTempClobsToFree = null;
  ArrayList oldTempBlobsToFree = null;

  private static final String _Copyright_2004_Oracle_All_Rights_Reserved_ = null;
  public static final boolean TRACE = false;
  public static final boolean PRIVATE_TRACE = false;
  public static final String BUILD_DATE = "Wed_Jun_22_11:18:51_PDT_2005";

  abstract void doDescribe(boolean paramBoolean)
    throws SQLException;

  abstract void executeForDescribe()
    throws SQLException;

  abstract void executeForRows(boolean paramBoolean)
    throws SQLException;

  abstract void fetch()
    throws SQLException;

  void continueReadRow(int paramInt)
    throws SQLException
  {
    throw new SQLException("continueReadRow is only implemented by the T4C statements.");
  }

  abstract void doClose()
    throws SQLException;

  abstract void closeQuery()
    throws SQLException;

  OracleStatement(PhysicalConnection paramPhysicalConnection, int paramInt1, int paramInt2)
    throws SQLException
  {
    this(paramPhysicalConnection, paramInt1, paramInt2, -1, -1);
  }

  OracleStatement(PhysicalConnection paramPhysicalConnection, int paramInt1, int paramInt2, int paramInt3, int paramInt4)
    throws SQLException
  {
    this.connection = paramPhysicalConnection;

    this.connection.needLine();

    this.connection.addStatement(this);

    this.sqlObject = new OracleSql(this.connection.conversion);
    this.sqlObject.isV8Compatible = this.connection.v8Compatible;

    this.processEscapes = this.connection.processEscapes;
    this.convertNcharLiterals = this.connection.convertNcharLiterals;
    this.autoRollback = 2;
    this.gotLastBatch = false;
    this.closed = false;
    this.clearParameters = true;
    this.serverCursor = false;
    this.needToAddIdentifier = false;
    this.defaultFetchDirection = 1000;
    this.fixedString = this.connection.getDefaultFixedString();
    this.rowPrefetchChanged = false;
    this.rowPrefetch = paramInt2;
    this.defaultRowPrefetch = paramInt2;
    this.batch = paramInt1;
    this.autoRefetch = this.connection.getDefaultAutoRefetch();

    this.sqlStringChanged = true;
    this.needToParse = true;
    this.needToPrepareDefineBuffer = true;
    this.columnsDefinedByUser = false;

    if ((paramInt3 != -1) || (paramInt4 != -1))
    {
      this.realRsetType = 0;
      this.userRsetType = ResultSetUtil.getRsetTypeCode(paramInt3, paramInt4);

      this.needToAddIdentifier = ResultSetUtil.needIdentifier(this.userRsetType);
    }
    else
    {
      this.userRsetType = 1;
      this.realRsetType = 1;
    }
  }

  void initializeDefineSubRanges()
  {
    this.defineByteSubRange = 0;
    this.defineCharSubRange = 0;
    this.defineIndicatorSubRange = 0;
  }

  void prepareDefinePreambles()
  {
  }

  void prepareAccessors()
    throws SQLException
  {
    byte[] arrayOfByte = null;
    char[] arrayOfChar = null;
    short[] arrayOfShort = null;
    boolean bool = false;

    if (this.accessors == null) {
      DatabaseError.throwSqlException(21);
    }

    int i = 0;
    int j = 0;
    Accessor localAccessor;
    for (int k = 0; k < this.numberOfDefinePositions; k++)
    {
      localAccessor = this.accessors[k];

      if (localAccessor == null) {
        DatabaseError.throwSqlException(21);
      }
      i += localAccessor.byteLength;
      j += localAccessor.charLength;
    }

    if ((this.streamList != null) && (!this.connection.useFetchSizeWithLongColumn)) {
      this.rowPrefetch = 1;
    }
    k = this.rowPrefetch;

    this.definesBatchSize = k;

    initializeDefineSubRanges();

    int m = this.defineByteSubRange + i * k;

    if ((this.defineBytes == null) || (this.defineBytes.length < m))
    {
      if (this.defineBytes != null) arrayOfByte = this.defineBytes;
      this.defineBytes = new byte[m];
    }

    this.defineByteSubRange += this.accessorByteOffset;

    int n = this.defineCharSubRange + j * k;

    if (((this.defineChars == null) || (this.defineChars.length < n)) && (n > 0))
    {
      if (this.defineChars != null) arrayOfChar = this.defineChars;
      this.defineChars = new char[n];
    }

    this.defineCharSubRange += this.accessorCharOffset;

    int i1 = this.numberOfDefinePositions * k;
    int i2 = this.defineIndicatorSubRange + i1 + i1;

    if ((this.defineIndicators == null) || (this.defineIndicators.length < i2))
    {
      if (this.defineIndicators != null) arrayOfShort = this.defineIndicators;
      this.defineIndicators = new short[i2];
    } else if (this.defineIndicators.length > i2)
    {
      bool = true;
      arrayOfShort = this.defineIndicators;
    }

    this.defineIndicatorSubRange += this.accessorShortOffset;

    int i3 = this.defineIndicatorSubRange + i1;

    for (int i4 = 0; i4 < this.numberOfDefinePositions; i4++)
    {
      localAccessor = this.accessors[i4];

      localAccessor.lengthIndexLastRow = localAccessor.lengthIndex;
      localAccessor.indicatorIndexLastRow = localAccessor.indicatorIndex;
      localAccessor.columnIndexLastRow = localAccessor.columnIndex;

      localAccessor.setOffsets(k);

      localAccessor.lengthIndex = i3;
      localAccessor.indicatorIndex = this.defineIndicatorSubRange;
      localAccessor.rowSpaceByte = this.defineBytes;
      localAccessor.rowSpaceChar = this.defineChars;
      localAccessor.rowSpaceIndicator = this.defineIndicators;
      this.defineIndicatorSubRange += k;
      i3 += k;
    }

    prepareDefinePreambles();

    if ((arrayOfChar != null) || (arrayOfByte != null))
    {
      saveDefineBuffersIfRequired(arrayOfChar, arrayOfByte, arrayOfShort != null ? arrayOfShort : this.defineIndicators, bool);
    }
    else if ((bool) && (this.saved_rowPrefetch != -1) && (this.rowPrefetch != this.saved_rowPrefetch))
    {
      saveDefineBuffersIfRequired(this.defineChars, this.defineBytes, this.defineIndicators, bool);
    }

    this.saved_rowPrefetch = -1;
  }

  boolean checkAccessorsUsable()
    throws SQLException
  {
    int i = this.accessors.length;

    if (i < this.numberOfDefinePositions) {
      return false;
    }
    int j = 1;
    int k = 0;
    int m = 0;

    for (int n = 0; n < this.numberOfDefinePositions; n++)
    {
      Accessor localAccessor = this.accessors[n];

      if ((localAccessor == null) || (localAccessor.externalType == 0))
        j = 0;
      else {
        k = 1;
      }
    }
    if (j != 0)
    {
      m = 1;
    } else if (k != 0)
    {
      DatabaseError.throwSqlException(21);
    }
    else
    {
      this.columnsDefinedByUser = false;
    }
    return m;
  }

  void executeMaybeDescribe()
    throws SQLException
  {
    cleanOldTempLobs();

    if (this.rowPrefetchChanged)
    {
      if ((this.streamList == null) && (this.rowPrefetch != this.definesBatchSize)) {
        this.needToPrepareDefineBuffer = true;
      }
      this.rowPrefetchChanged = false;
    }

    if (!this.needToPrepareDefineBuffer)
    {
      if (this.accessors == null)
      {
        this.needToPrepareDefineBuffer = true;
      } else if (this.columnsDefinedByUser) {
        this.needToPrepareDefineBuffer = (!checkAccessorsUsable());
      }
    }
    boolean bool = false;
    try
    {
      this.isExecuting = true;

      if (this.needToPrepareDefineBuffer)
      {
        if (!this.columnsDefinedByUser)
        {
          executeForDescribe();

          bool = true;
        }

        prepareAccessors();
      }

      int i = this.accessors.length;

      for (int j = this.numberOfDefinePositions; j < i; j++)
      {
        Accessor localAccessor = this.accessors[j];

        if (localAccessor != null) {
          localAccessor.rowSpaceIndicator = null;
        }
      }
      executeForRows(bool);
    }
    catch (SQLException localSQLException)
    {
      this.needToParse = true;
      throw localSQLException;
    }
    finally
    {
      this.isExecuting = false;
    }
  }

  void adjustGotLastBatch()
  {
  }

  void doExecuteWithTimeout()
    throws SQLException
  {
    this.rowsProcessed = 0;

    if (this.sqlKind == 0)
    {
      if ((this.connection.j2ee13Compliant) && (this.executionType == 2)) {
        DatabaseError.throwSqlException(129);
      }
      this.connection.needLine();

      if (!this.isOpen)
      {
        this.connection.open(this);

        this.isOpen = true;
      }

      this.connection.registerHeartbeat();

      if (this.queryTimeout != 0)
      {
        try
        {
          this.connection.getTimeout().setTimeout(this.queryTimeout * 1000, this);
          executeMaybeDescribe();
        }
        finally
        {
          this.connection.getTimeout().cancelTimeout();
        }
      }
      else {
        executeMaybeDescribe();
      }
      checkValidRowsStatus();

      if (this.serverCursor)
        adjustGotLastBatch();
    }
    else
    {
      if ((this.connection.j2ee13Compliant) && (this.sqlKind != 1) && (this.sqlKind != 4) && (this.executionType == 1))
      {
        DatabaseError.throwSqlException(128);
      }
      this.currentRank += 1;

      if (this.currentRank >= this.batch)
      {
        try
        {
          this.connection.needLine();

          if (!this.isOpen)
          {
            this.connection.open(this);

            this.isOpen = true;
          }

          if (this.queryTimeout != 0) {
            this.connection.getTimeout().setTimeout(this.queryTimeout * 1000, this);
          }
          this.isExecuting = true;

          executeForRows(false);
        }
        catch (SQLException localSQLException)
        {
          this.needToParse = true;
          throw localSQLException;
        }
        finally
        {
          if (this.queryTimeout != 0) {
            this.connection.getTimeout().cancelTimeout();
          }
          this.currentRank = 0;
          this.isExecuting = false;

          checkValidRowsStatus();
        }
      }
    }
  }

  void open()
    throws SQLException
  {
    if (!this.isOpen)
    {
      this.connection.needLine();
      this.connection.open(this);

      this.isOpen = true;
    }
  }

  public ResultSet executeQuery(String paramString)
    throws SQLException
  {
    Object localObject1 = null;

    synchronized (this.connection)
    {
      synchronized (this)
      {
        try
        {
          this.executionType = 1;

          this.noMoreUpdateCounts = false;

          ensureOpen();
          checkIfJdbcBatchExists();

          sendBatch();

          this.sqlObject.initialize(paramString);

          this.sqlKind = this.sqlObject.getSqlKind();
          this.needToParse = true;

          prepareForNewResults(true, true);

          if (this.userRsetType == 1)
          {
            doExecuteWithTimeout();

            this.currentResultSet = new OracleResultSetImpl(this.connection, this);
            localObject1 = this.currentResultSet;
          }
          else
          {
            localObject1 = doScrollStmtExecuteQuery();

            if (localObject1 == null)
            {
              this.currentResultSet = new OracleResultSetImpl(this.connection, this);
              localObject1 = this.currentResultSet;
            }
          }
        }
        finally
        {
          this.executionType = -1;
        }
      }
    }

    return (ResultSet)localObject1;
  }

  public void closeWithKey(String paramString)
    throws SQLException
  {
    DatabaseError.throwSqlException(23);
  }

  public void close()
    throws SQLException
  {
    synchronized (this.connection)
    {
      synchronized (this)
      {
        closeOrCache(null);
      }
    }
  }

  protected void closeOrCache(String paramString)
    throws SQLException
  {
    if (this.closed) {
      return;
    }

    if ((this.statementType != 0) && (this.cacheState != 0) && (this.cacheState != 3) && (this.connection.isStatementCacheInitialized()))
    {
      if (paramString == null)
      {
        if (this.connection.getImplicitCachingEnabled())
        {
          this.connection.cacheImplicitStatement((OraclePreparedStatement)this, this.sqlObject.getOriginalSql(), this.statementType, this.userRsetType);
        }
        else
        {
          this.cacheState = 0;

          hardClose();
        }

      }
      else if (this.connection.getExplicitCachingEnabled())
      {
        this.connection.cacheExplicitStatement((OraclePreparedStatement)this, paramString);
      }
      else
      {
        this.cacheState = 0;

        hardClose();
      }

    }
    else
    {
      hardClose();
    }
  }

  protected void hardClose()
    throws SQLException
  {
    hardClose(true);
  }

  private void hardClose(boolean paramBoolean)
    throws SQLException
  {
    alwaysOnClose();

    this.describedWithNames = false;
    this.described = false;

    this.connection.removeStatement(this);

    cleanupDefines();

    if ((this.isOpen) && (paramBoolean) && (!this.connection.isClosed()))
    {
      doClose();

      this.isOpen = false;
    }

    this.sqlObject = null;
  }

  protected void alwaysOnClose()
    throws SQLException
  {
    Object localObject = this.children;

    while (localObject != null)
    {
      OracleStatement localOracleStatement = ((OracleStatement)localObject).nextChild;

      ((OracleStatement)localObject).close();

      localObject = localOracleStatement;
    }

    this.closed = true;

    if (!this.connection.isClosed())
    {
      this.connection.needLine();

      if (this.currentResultSet != null)
      {
        this.currentResultSet.internal_close(false);

        this.currentResultSet = null;
      }

      if (this.scrollRset != null)
      {
        this.scrollRset.close();

        this.scrollRset = null;
      }

      if (this.returnResultSet != null)
      {
        this.returnResultSet.close();
        this.returnResultSet = null;
      }
    }

    clearWarnings();

    this.m_batchItems = null;
  }

  void closeLeaveCursorOpen()
    throws SQLException
  {
    synchronized (this.connection)
    {
      synchronized (this)
      {
        if (this.closed)
        {
          return;
        }

        hardClose(false);
      }
    }
  }

  public int executeUpdate(String paramString)
    throws SQLException
  {
    synchronized (this.connection)
    {
      synchronized (this)
      {
        setNonAutoKey();
        return executeUpdateInternal(paramString);
      }
    }
  }

  int executeUpdateInternal(String paramString)
    throws SQLException
  {
    try
    {
      if (this.executionType == -1) {
        this.executionType = 2;
      }

      this.noMoreUpdateCounts = false;

      ensureOpen();
      checkIfJdbcBatchExists();

      sendBatch();

      this.sqlObject.initialize(paramString);

      this.sqlKind = this.sqlObject.getSqlKind();
      this.needToParse = true;

      prepareForNewResults(true, true);

      if (this.userRsetType == 1)
      {
        doExecuteWithTimeout();
      }
      else
      {
        doScrollStmtExecuteQuery();
      }

      int i = this.validRows;
      return i; } finally { this.executionType = -1; } throw localObject;
  }

  public boolean execute(String paramString)
    throws SQLException
  {
    synchronized (this.connection)
    {
      synchronized (this)
      {
        setNonAutoKey();

        return executeInternal(paramString);
      }
    }
  }

  boolean executeInternal(String paramString)
    throws SQLException
  {
    try
    {
      this.executionType = 3;

      this.noMoreUpdateCounts = false;

      ensureOpen();
      checkIfJdbcBatchExists();

      sendBatch();

      this.sqlObject.initialize(paramString);

      this.sqlKind = this.sqlObject.getSqlKind();
      this.needToParse = true;

      prepareForNewResults(true, true);

      if (this.userRsetType == 1)
      {
        doExecuteWithTimeout();
      }
      else
      {
        doScrollStmtExecuteQuery();
      }

      int i = this.sqlKind == 0 ? 1 : 0;
      return i; } finally { this.executionType = -1; } throw localObject;
  }

  int getNumberOfColumns()
    throws SQLException
  {
    if (!this.described) {
      synchronized (this.connection)
      {
        synchronized (this)
        {
          this.connection.needLine();
          doDescribe(false);

          this.described = true;
        }
      }
    }
    return this.numberOfDefinePositions;
  }

  Accessor[] getDescription() throws SQLException
  {
    if (!this.described) {
      synchronized (this.connection)
      {
        synchronized (this)
        {
          this.connection.needLine();
          doDescribe(false);

          this.described = true;
        }
      }
    }
    return this.accessors;
  }

  Accessor[] getDescriptionWithNames() throws SQLException
  {
    if (!this.describedWithNames) {
      synchronized (this.connection)
      {
        synchronized (this)
        {
          this.connection.needLine();
          doDescribe(true);

          this.described = true;
          this.describedWithNames = true;
        }
      }
    }
    return this.accessors;
  }

  byte getSqlKind()
  {
    return this.sqlKind;
  }

  public synchronized void clearDefines()
    throws SQLException
  {
    freeLine();

    this.streamList = null;

    this.columnsDefinedByUser = false;
    this.needToPrepareDefineBuffer = true;

    this.numberOfDefinePositions = 0;
    this.definesBatchSize = 0;

    this.described = false;
    this.describedWithNames = false;

    cleanupDefines();
  }

  void reparseOnRedefineIfNeeded()
    throws SQLException
  {
  }

  void defineColumnTypeInternal(int paramInt1, int paramInt2, int paramInt3, boolean paramBoolean, String paramString)
    throws SQLException
  {
    defineColumnTypeInternal(paramInt1, paramInt2, paramInt3, 1, paramBoolean, paramString);
  }

  void defineColumnTypeInternal(int paramInt1, int paramInt2, int paramInt3, short paramShort, boolean paramBoolean, String paramString)
    throws SQLException
  {
    if (this.connection.disableDefineColumnType)
    {
      return;
    }

    if (paramInt1 < 1) {
      DatabaseError.throwSqlException(3);
    }
    if (paramInt2 == 0) {
      DatabaseError.throwSqlException(4);
    }
    int i = paramInt1 - 1;
    int j = this.maxFieldSize;

    if (paramBoolean)
    {
      if ((paramInt2 == 1) || (paramInt2 == 12)) {
        this.sqlWarning = DatabaseError.addSqlWarning(this.sqlWarning, 108);
      }

    }
    else
    {
      if (paramInt3 < 0) {
        DatabaseError.throwSqlException(53);
      }
      if ((j == 0) || (paramInt3 < j)) {
        j = paramInt3;
      }
    }
    if ((this.currentResultSet != null) && (!this.currentResultSet.closed)) {
      DatabaseError.throwSqlException(28);
    }
    if (!this.columnsDefinedByUser)
    {
      clearDefines();

      this.columnsDefinedByUser = true;
    }

    if (this.numberOfDefinePositions < paramInt1)
    {
      if ((this.accessors == null) || (this.accessors.length < paramInt1))
      {
        Accessor[] arrayOfAccessor = new Accessor[paramInt1 << 1];

        if (this.accessors != null) {
          System.arraycopy(this.accessors, 0, arrayOfAccessor, 0, this.numberOfDefinePositions);
        }
        this.accessors = arrayOfAccessor;
      }

      this.numberOfDefinePositions = paramInt1;
    }

    int k = getInternalType(paramInt2);

    if (((k == 109) || (k == 111)) && ((paramString == null) || (paramString.equals(""))))
    {
      DatabaseError.throwSqlException(60, "Invalid arguments");
    }

    Accessor localAccessor = this.accessors[i];
    int m = 1;

    if (localAccessor != null)
    {
      int n = localAccessor.useForDataAccessIfPossible(k, paramInt2, j, paramString);

      if (n == 0)
      {
        paramShort = localAccessor.formOfUse;
        localAccessor = null;

        reparseOnRedefineIfNeeded();
      }
      else if (n == 1)
      {
        localAccessor = null;

        reparseOnRedefineIfNeeded();
      }
      else if (n == 2) {
        m = 0;
      }
    }
    if (m != 0) {
      this.needToPrepareDefineBuffer = true;
    }
    if (localAccessor == null)
    {
      this.accessors[i] = allocateAccessor(k, paramInt2, paramInt1, j, paramShort, paramString, false);

      this.described = false;
      this.describedWithNames = false;
    }
  }

  Accessor allocateAccessor(int paramInt1, int paramInt2, int paramInt3, int paramInt4, short paramShort, String paramString, boolean paramBoolean)
    throws SQLException
  {
    Object localObject;
    switch (paramInt1)
    {
    case 96:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new CharAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 8:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      if (paramBoolean) break;
      return new LongAccessor(this, paramInt3, paramInt4, paramShort, paramInt2);
    case 1:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new VarcharAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 2:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new NumberAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 6:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new VarnumAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 24:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      if (!paramBoolean) {
        return new LongRawAccessor(this, paramInt3, paramInt4, paramShort, paramInt2);
      }

    case 23:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      if (paramBoolean) {
        return new OutRawAccessor(this, paramInt4, paramShort, paramInt2);
      }
      return new RawAccessor(this, paramInt4, paramShort, paramInt2, false);
    case 100:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new BinaryFloatAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 101:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new BinaryDoubleAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 104:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new RowidAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 102:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new ResultSetAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 12:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new DateAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 113:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new BlobAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 112:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new ClobAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 114:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new BfileAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 109:
      if (paramString == null) {
        if (paramBoolean) {
          DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
        }
        else {
          DatabaseError.throwSqlException(60, "Unable to resolve type \"null\"");
        }
      }
      localObject = new NamedTypeAccessor(this, paramString, paramShort, paramInt2, paramBoolean);

      ((Accessor)localObject).initMetadata();

      return localObject;
    case 111:
      if (paramString == null) {
        if (paramBoolean) {
          DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
        }
        else {
          DatabaseError.throwSqlException(60, "Unable to resolve type \"null\"");
        }
      }
      localObject = new RefTypeAccessor(this, paramString, paramShort, paramInt2, paramBoolean);

      ((Accessor)localObject).initMetadata();

      return localObject;
    case 180:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      if (this.connection.v8Compatible) {
        return new DateAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
      }
      return new TimestampAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 181:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new TimestamptzAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 231:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new TimestampltzAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 182:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new IntervalymAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 183:
      if ((paramBoolean) && (paramString != null)) {
        DatabaseError.throwSqlException(12, "sqlType=" + paramInt2);
      }

      return new IntervaldsAccessor(this, paramInt4, paramShort, paramInt2, paramBoolean);
    case 995:
      DatabaseError.throwSqlException(89);
    }

    DatabaseError.throwSqlException(4);

    return (Accessor)null;
  }

  public synchronized void defineColumnType(int paramInt1, int paramInt2)
    throws SQLException
  {
    defineColumnTypeInternal(paramInt1, paramInt2, 0, true, null);
  }

  public void defineColumnType(int paramInt1, int paramInt2, int paramInt3)
    throws SQLException
  {
    defineColumnTypeInternal(paramInt1, paramInt2, paramInt3, false, null);
  }

  public void defineColumnType(int paramInt1, int paramInt2, int paramInt3, short paramShort)
    throws SQLException
  {
    defineColumnTypeInternal(paramInt1, paramInt2, paramInt3, paramShort, false, null);
  }

  public synchronized void defineColumnTypeBytes(int paramInt1, int paramInt2, int paramInt3)
    throws SQLException
  {
    defineColumnTypeInternal(paramInt1, paramInt2, paramInt3, false, null);
  }

  public void defineColumnTypeChars(int paramInt1, int paramInt2, int paramInt3)
    throws SQLException
  {
    defineColumnTypeInternal(paramInt1, paramInt2, paramInt3, false, null);
  }

  public void defineColumnType(int paramInt1, int paramInt2, String paramString)
    throws SQLException
  {
    synchronized (this.connection)
    {
      synchronized (this)
      {
        defineColumnTypeInternal(paramInt1, paramInt2, 0, true, paramString);
      }
    }
  }

  void setCursorId(int paramInt)
    throws SQLException
  {
    this.cursorId = paramInt;
  }

  void setPrefetchInternal(int paramInt, boolean paramBoolean1, boolean paramBoolean2)
    throws SQLException
  {
    if (paramBoolean1)
    {
      if (paramInt <= 0) {
        DatabaseError.throwSqlException(20);
      }

    }
    else if (paramInt < 0) {
      DatabaseError.throwSqlException(68, "setFetchSize");
    }
    else if (paramInt == 0) {
      paramInt = this.connection.getDefaultRowPrefetch();
    }

    if (paramBoolean2)
    {
      if (paramInt != this.defaultRowPrefetch)
      {
        this.saved_rowPrefetch = this.rowPrefetch;
        this.defaultRowPrefetch = paramInt;

        if ((this.currentResultSet == null) || (this.currentResultSet.closed)) {
          this.rowPrefetchChanged = true;
        }

      }

    }
    else if ((paramInt != this.rowPrefetch) && (this.streamList == null))
    {
      this.saved_rowPrefetch = this.rowPrefetch;
      this.rowPrefetch = paramInt;
      this.rowPrefetchChanged = true;
    }
  }

  public synchronized void setRowPrefetch(int paramInt)
    throws SQLException
  {
    setPrefetchInternal(paramInt, true, true);
  }

  int getPrefetchInternal(boolean paramBoolean)
  {
    int i = paramBoolean ? this.defaultRowPrefetch : this.rowPrefetch;

    return i;
  }

  public synchronized int getRowPrefetch()
  {
    return getPrefetchInternal(true);
  }

  public void setFixedString(boolean paramBoolean)
  {
    this.fixedString = paramBoolean;
  }

  public boolean getFixedString()
  {
    return this.fixedString;
  }

  void check_row_prefetch_changed()
    throws SQLException
  {
    if (this.rowPrefetchChanged)
    {
      if (this.streamList == null)
      {
        prepareAccessors();

        this.needToPrepareDefineBuffer = true;
      }

      this.rowPrefetchChanged = false;
    }
  }

  void setDefinesInitialized(boolean paramBoolean)
  {
  }

  void printState(String paramString)
    throws SQLException
  {
  }

  void checkValidRowsStatus()
    throws SQLException
  {
    if (this.validRows == -2)
    {
      this.validRows = 1;

      this.connection.holdLine(this);

      OracleInputStream localOracleInputStream = this.streamList;

      while (localOracleInputStream != null)
      {
        if (localOracleInputStream.hasBeenOpen) {
          localOracleInputStream = localOracleInputStream.accessor.initForNewRow();
        }

        localOracleInputStream.closed = false;
        localOracleInputStream.hasBeenOpen = true;

        localOracleInputStream = localOracleInputStream.nextStream;
      }

      this.nextStream = this.streamList;
    }
    else if (this.sqlKind == 0)
    {
      if (this.validRows < this.rowPrefetch)
        this.gotLastBatch = true;
    }
    else if ((this.sqlKind != 1) && (this.sqlKind != 4))
    {
      this.rowsProcessed = this.validRows;
    }
  }

  void cleanupDefines()
  {
    if (this.accessors != null) {
      for (int i = 0; i < this.accessors.length; i++)
        this.accessors[i] = null;
    }
    this.accessors = null;

    if (this.defineBytes != null)
    {
      this.defineBytes = null;
    }

    if (this.defineChars != null)
    {
      this.defineChars = null;
    }

    if (this.defineIndicators != null)
    {
      this.defineIndicators = null;
    }
  }

  public synchronized int getMaxFieldSize() throws SQLException
  {
    return this.maxFieldSize;
  }

  public synchronized void setMaxFieldSize(int paramInt)
    throws SQLException
  {
    if (paramInt < 0) {
      DatabaseError.throwSqlException(68);
    }
    this.maxFieldSize = paramInt;
  }

  public int getMaxRows() throws SQLException
  {
    return this.maxRows;
  }

  public synchronized void setMaxRows(int paramInt)
    throws SQLException
  {
    if (paramInt < 0) {
      DatabaseError.throwSqlException(68);
    }
    this.maxRows = paramInt;
  }

  public synchronized void setEscapeProcessing(boolean paramBoolean)
    throws SQLException
  {
    this.processEscapes = paramBoolean;
  }

  public synchronized int getQueryTimeout()
    throws SQLException
  {
    return this.queryTimeout;
  }

  public synchronized void setQueryTimeout(int paramInt)
    throws SQLException
  {
    if (paramInt < 0) {
      DatabaseError.throwSqlException(68);
    }
    this.queryTimeout = paramInt;
  }

  public void cancel()
    throws SQLException
  {
    if (this.closed) {
      return;
    }

    if (this.connection.statementHoldingLine != null)
      freeLine();
    else if (this.isExecuting) {
      this.connection.doCancel();
    }
    this.connection.releaseLineForCancel();
  }

  public SQLWarning getWarnings()
    throws SQLException
  {
    return this.sqlWarning;
  }

  public void clearWarnings()
    throws SQLException
  {
    this.sqlWarning = null;
  }

  void foundPlsqlCompilerWarning()
    throws SQLException
  {
    SQLWarning localSQLWarning = DatabaseError.newSqlWarning("Found Plsql compiler warnings.", "99999", 24439);

    if (this.sqlWarning != null)
      this.sqlWarning.setNextWarning(localSQLWarning);
    else
      this.sqlWarning = localSQLWarning;
  }

  public void setCursorName(String paramString)
    throws SQLException
  {
    DatabaseError.throwSqlException(23);
  }

  public synchronized ResultSet getResultSet()
    throws SQLException
  {
    if (this.userRsetType == 1)
    {
      if (this.sqlKind == 0)
      {
        if (this.currentResultSet == null) {
          this.currentResultSet = new OracleResultSetImpl(this.connection, this);
        }
        return this.currentResultSet;
      }
    }
    else
    {
      return this.scrollRset;
    }

    return null;
  }

  public synchronized int getUpdateCount()
    throws SQLException
  {
    int i = -1;

    switch (this.sqlKind)
    {
    case -1:
    case 0:
      break;
    case 3:
      if (!this.noMoreUpdateCounts) {
        i = this.rowsProcessed;
      }
      this.noMoreUpdateCounts = true;

      break;
    case 1:
    case 4:
      this.noMoreUpdateCounts = true;

      break;
    case 2:
      if (!this.noMoreUpdateCounts) {
        i = this.rowsProcessed;
      }
      this.noMoreUpdateCounts = true;
    }

    return i;
  }

  public boolean getMoreResults()
    throws SQLException
  {
    return false;
  }

  public int sendBatch()
    throws SQLException
  {
    return 0;
  }

  void prepareForNewResults(boolean paramBoolean1, boolean paramBoolean2)
    throws SQLException
  {
    clearWarnings();

    if (this.streamList != null)
    {
      while (this.nextStream != null)
      {
        try
        {
          this.nextStream.close();
        }
        catch (IOException localIOException)
        {
          DatabaseError.throwSqlException(localIOException);
        }

        this.nextStream = this.nextStream.nextStream;
      }

      if (paramBoolean2)
      {
        OracleInputStream localOracleInputStream1 = this.streamList;
        OracleInputStream localOracleInputStream2 = null;

        this.streamList = null;

        while (localOracleInputStream1 != null)
        {
          if (!localOracleInputStream1.hasBeenOpen)
          {
            if (localOracleInputStream2 == null)
              this.streamList = localOracleInputStream1;
            else {
              localOracleInputStream2.nextStream = localOracleInputStream1;
            }
            localOracleInputStream2 = localOracleInputStream1;
          }

          localOracleInputStream1 = localOracleInputStream1.nextStream;
        }
      }
    }

    if (this.currentResultSet != null)
    {
      this.currentResultSet.internal_close(true);

      this.currentResultSet = null;
    }

    this.currentRow = -1;
    this.validRows = 0;
    this.totalRowsVisited = 0;
    this.gotLastBatch = false;

    if ((this.needToParse) && (!this.columnsDefinedByUser))
    {
      if ((paramBoolean2) && (this.numberOfDefinePositions != 0)) {
        this.numberOfDefinePositions = 0;
      }
      this.needToPrepareDefineBuffer = true;
    }

    if ((paramBoolean1) && (this.rowPrefetch != this.defaultRowPrefetch) && (this.streamList == null))
    {
      this.rowPrefetch = this.defaultRowPrefetch;
      this.rowPrefetchChanged = true;
    }
  }

  void reopenStreams()
    throws SQLException
  {
    OracleInputStream localOracleInputStream = this.streamList;

    while (localOracleInputStream != null)
    {
      if (localOracleInputStream.hasBeenOpen) {
        localOracleInputStream = localOracleInputStream.accessor.initForNewRow();
      }
      localOracleInputStream.closed = false;
      localOracleInputStream.hasBeenOpen = true;
      localOracleInputStream = localOracleInputStream.nextStream;
    }

    this.nextStream = this.streamList;
  }

  void endOfResultSet(boolean paramBoolean)
    throws SQLException
  {
    if (!paramBoolean)
    {
      prepareForNewResults(false, false);
    }

    clearDefines();
  }

  boolean wasNullValue()
    throws SQLException
  {
    if (this.lastIndex == 0) {
      DatabaseError.throwSqlException(24);
    }
    if (this.sqlKind == 0) {
      return this.accessors[(this.lastIndex - 1)].isNull(this.currentRow);
    }
    return this.outBindAccessors[(this.lastIndex - 1)].isNull(this.currentRank);
  }

  int getColumnIndex(String paramString)
    throws SQLException
  {
    if (!this.describedWithNames) {
      synchronized (this.connection)
      {
        synchronized (this)
        {
          this.connection.needLine();
          doDescribe(true);

          this.described = true;
          this.describedWithNames = true;
        }
      }
    }
    for (int i = 0; i < this.numberOfDefinePositions; i++) {
      if (this.accessors[i].columnName.equalsIgnoreCase(paramString))
        return i + 1;
    }
    DatabaseError.throwSqlException(6);

    return 0;
  }

  int getInternalType(int paramInt)
    throws SQLException
  {
    int i = 0;

    switch (paramInt)
    {
    case -7:
    case -6:
    case -5:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      i = 6;
      break;
    case 100:
      i = 100;
      break;
    case 101:
      i = 101;
      break;
    case 999:
      i = 999;
      break;
    case 1:
      i = 96;
      break;
    case 12:
      i = 1;
      break;
    case -1:
      i = 8;
      break;
    case 91:
    case 92:
      i = 12;
      break;
    case -100:
    case 93:
      i = 180;
      break;
    case -101:
      i = 181;
      break;
    case -102:
      i = 231;
      break;
    case -103:
      i = 182;
      break;
    case -104:
      i = 183;
      break;
    case -3:
    case -2:
      i = 23;
      break;
    case -4:
      i = 24;
      break;
    case -8:
      i = 104;
      break;
    case 2004:
      i = 113;
      break;
    case 2005:
      i = 112;
      break;
    case -13:
      i = 114;
      break;
    case -10:
      i = 102;
      break;
    case 2002:
    case 2003:
    case 2007:
    case 2008:
      i = 109;
      break;
    case 2006:
      i = 111;
      break;
    case -14:
      i = 998;
      break;
    case 70:
      i = 1;
      break;
    case 0:
      i = 995;
      break;
    default:
      DatabaseError.throwSqlException(4);
    }

    return i;
  }

  void describe()
    throws SQLException
  {
    synchronized (this.connection)
    {
      synchronized (this)
      {
        if (!this.described)
        {
          this.connection.needLine();
          doDescribe(false);
        }
      }
    }
  }

  void freeLine() throws SQLException
  {
    if (this.streamList != null)
    {
      while (this.nextStream != null)
      {
        try
        {
          this.nextStream.close();
        }
        catch (IOException localIOException)
        {
          DatabaseError.throwSqlException(localIOException);
        }

        this.nextStream = this.nextStream.nextStream;
      }
    }
  }

  void closeUsedStreams(int paramInt)
    throws SQLException
  {
    while ((this.nextStream != null) && (this.nextStream.columnIndex < paramInt))
    {
      try
      {
        this.nextStream.close();
      }
      catch (IOException localIOException)
      {
        DatabaseError.throwSqlException(localIOException);
      }

      this.nextStream = this.nextStream.nextStream;
    }
  }

  final void ensureOpen()
    throws SQLException
  {
    if (this.connection.lifecycle != 1)
      DatabaseError.throwSqlException(8);
    if (this.closed)
      DatabaseError.throwSqlException(9);
  }

  void allocateTmpByteArray()
  {
  }

  public synchronized void setFetchDirection(int paramInt)
    throws SQLException
  {
    if (paramInt == 1000)
    {
      this.defaultFetchDirection = paramInt;
    }
    else if ((paramInt == 1001) || (paramInt == 1002))
    {
      this.defaultFetchDirection = 1000;
      this.sqlWarning = DatabaseError.addSqlWarning(this.sqlWarning, 87);
    }
    else
    {
      DatabaseError.throwSqlException(68, "setFetchDirection");
    }
  }

  public int getFetchDirection()
    throws SQLException
  {
    return this.defaultFetchDirection;
  }

  public synchronized void setFetchSize(int paramInt)
    throws SQLException
  {
    setPrefetchInternal(paramInt, false, true);
  }

  public int getFetchSize()
    throws SQLException
  {
    return getPrefetchInternal(true);
  }

  public int getResultSetConcurrency()
    throws SQLException
  {
    return ResultSetUtil.getUpdateConcurrency(this.userRsetType);
  }

  public int getResultSetType()
    throws SQLException
  {
    return ResultSetUtil.getScrollType(this.userRsetType);
  }

  public Connection getConnection()
    throws SQLException
  {
    return this.connection.getWrapper();
  }

  public synchronized void setResultSetCache(oracle.jdbc.OracleResultSetCache paramOracleResultSetCache)
    throws SQLException
  {
    try
    {
      if (paramOracleResultSetCache == null) {
        DatabaseError.throwSqlException(68);
      }
      if (this.rsetCache != null) {
        this.rsetCache.close();
      }
      this.rsetCache = paramOracleResultSetCache;
    }
    catch (IOException localIOException)
    {
      DatabaseError.throwSqlException(localIOException);
    }
  }

  public synchronized void setResultSetCache(OracleResultSetCache paramOracleResultSetCache)
    throws SQLException
  {
    setResultSetCache(paramOracleResultSetCache);
  }

  public synchronized OracleResultSetCache getResultSetCache()
    throws SQLException
  {
    return (OracleResultSetCache)this.rsetCache;
  }

  void initBatch()
  {
  }

  int getBatchSize()
  {
    return this.m_batchItems.size();
  }

  void addBatchItem(String paramString)
  {
    this.m_batchItems.addElement(paramString);
  }

  String getBatchItem(int paramInt)
  {
    return (String)this.m_batchItems.elementAt(paramInt);
  }

  void clearBatchItems()
  {
    this.m_batchItems.removeAllElements();
  }

  void checkIfJdbcBatchExists()
    throws SQLException
  {
    if (getBatchSize() > 0)
    {
      DatabaseError.throwSqlException(81, "batch must be either executed or cleared");
    }
  }

  public synchronized void addBatch(String paramString)
    throws SQLException
  {
    addBatchItem(paramString);
  }

  public synchronized void clearBatch()
    throws SQLException
  {
    clearBatchItems();
  }

  public int[] executeBatch()
    throws SQLException
  {
    synchronized (this.connection)
    {
      synchronized (this)
      {
        cleanOldTempLobs();
        int i = 0;
        int j = getBatchSize();

        if (j <= 0)
        {
          return new int[0];
        }

        int[] arrayOfInt = new int[j];

        ensureOpen();

        prepareForNewResults(true, true);

        int k = this.numberOfDefinePositions;
        String str = this.sqlObject.getOriginalSql();
        byte b = this.sqlKind;

        this.noMoreUpdateCounts = false;

        int m = 0;
        try
        {
          this.connection.needLine();

          for (i = 0; i < j; i++)
          {
            this.sqlObject.initialize(getBatchItem(i));

            this.sqlKind = this.sqlObject.getSqlKind();

            this.needToParse = true;
            this.numberOfDefinePositions = 0;

            this.rowsProcessed = 0;
            this.currentRank = 1;

            if (this.sqlKind == 0)
            {
              DatabaseError.throwBatchUpdateException(80, "invalid SELECT batch command " + i, i, arrayOfInt);
            }

            if (!this.isOpen)
            {
              this.connection.open(this);

              this.isOpen = true;
            }

            int n = -1;
            try
            {
              if (this.queryTimeout != 0) {
                this.connection.getTimeout().setTimeout(this.queryTimeout * 1000, this);
              }
              this.isExecuting = true;

              executeForRows(false);

              if (this.validRows > 0) {
                m += this.validRows;
              }
              n = this.validRows;
            }
            catch (SQLException localSQLException2)
            {
              this.needToParse = true;
              throw localSQLException2;
            }
            finally
            {
              if (this.queryTimeout != 0) {
                this.connection.getTimeout().cancelTimeout();
              }
              this.validRows = m;

              checkValidRowsStatus();

              this.isExecuting = false;
            }

            arrayOfInt[i] = n;

            if (arrayOfInt[i] >= 0)
              continue;
            DatabaseError.throwBatchUpdateException(81, "command return value " + arrayOfInt[i], i, arrayOfInt);
          }

        }
        catch (SQLException localSQLException1)
        {
          if ((localSQLException1 instanceof BatchUpdateException))
          {
            throw localSQLException1;
          }

          DatabaseError.throwBatchUpdateException(81, localSQLException1.getMessage(), i, arrayOfInt);
        }
        finally
        {
          clearBatchItems();

          this.numberOfDefinePositions = k;

          if (str != null)
          {
            this.sqlObject.initialize(str);

            this.sqlKind = b;
          }

          this.currentRank = 0;
        }

        return arrayOfInt;
      }
    }
  }

  public int copyBinds(Statement paramStatement, int paramInt)
    throws SQLException
  {
    return 0;
  }

  public void notifyCloseRset()
    throws SQLException
  {
    this.scrollRset = null;

    endOfResultSet(false);
  }

  public String getOriginalSql()
    throws SQLException
  {
    return this.sqlObject.getOriginalSql();
  }

  void doScrollExecuteCommon()
    throws SQLException
  {
    if (this.scrollRset != null)
    {
      this.scrollRset.close();

      this.scrollRset = null;
    }

    if (this.sqlKind != 0)
    {
      doExecuteWithTimeout();

      return;
    }

    if (!this.needToAddIdentifier)
    {
      doExecuteWithTimeout();

      this.currentResultSet = new OracleResultSetImpl(this.connection, this);
      this.realRsetType = this.userRsetType;
    }
    else
    {
      try
      {
        this.sqlObject.setIncludeRowid(true);

        this.needToParse = true;

        prepareForNewResults(true, false);

        if (this.columnsDefinedByUser)
        {
          Accessor[] arrayOfAccessor = this.accessors;

          if ((this.accessors == null) || (this.accessors.length <= this.numberOfDefinePositions)) {
            this.accessors = new Accessor[this.numberOfDefinePositions + 1];
          }
          if (arrayOfAccessor != null) {
            for (i = this.numberOfDefinePositions; i > 0; i--)
            {
              localAccessor = arrayOfAccessor[(i - 1)];

              this.accessors[i] = localAccessor;

              if (!localAccessor.isColumnNumberAware)
              {
                continue;
              }

              localAccessor.updateColumnNumber(i);
            }

          }

          allocateRowidAccessor();

          this.numberOfDefinePositions += 1;
        }

        doExecuteWithTimeout();

        this.currentResultSet = new OracleResultSetImpl(this.connection, this);
        this.realRsetType = this.userRsetType;
      }
      catch (SQLException localSQLException)
      {
        int i;
        Accessor localAccessor;
        if (this.userRsetType > 3)
          this.realRsetType = 3;
        else {
          this.realRsetType = 1;
        }
        this.sqlObject.setIncludeRowid(false);

        this.needToParse = true;

        prepareForNewResults(true, false);

        if (this.columnsDefinedByUser)
        {
          this.needToPrepareDefineBuffer = true;
          this.numberOfDefinePositions -= 1;

          System.arraycopy(this.accessors, 1, this.accessors, 0, this.numberOfDefinePositions);

          this.accessors[this.numberOfDefinePositions] = null;

          for (i = 0; i < this.numberOfDefinePositions; i++)
          {
            localAccessor = this.accessors[i];

            if (!localAccessor.isColumnNumberAware)
            {
              continue;
            }

            localAccessor.updateColumnNumber(i);
          }
        }

        doExecuteWithTimeout();

        this.currentResultSet = new OracleResultSetImpl(this.connection, this);
        this.sqlWarning = DatabaseError.addSqlWarning(this.sqlWarning, 91, localSQLException.getMessage());
      }

    }

    this.scrollRset = ResultSetUtil.createScrollResultSet(this, this.currentResultSet, this.realRsetType);
  }

  void allocateRowidAccessor()
    throws SQLException
  {
    this.accessors[0] = new RowidAccessor(this, 128, 1, -8, false);
  }

  OracleResultSet doScrollStmtExecuteQuery()
    throws SQLException
  {
    doScrollExecuteCommon();

    return this.scrollRset;
  }

  void processDmlReturningBind()
    throws SQLException
  {
    if (this.returnResultSet != null) this.returnResultSet.close();

    this.returnParamsFetched = false;
    this.returnParamRowBytes = 0;
    this.returnParamRowChars = 0;

    int i = 0;
    for (int j = 0; j < this.numberOfBindPositions; j++)
    {
      Accessor localAccessor = this.returnParamAccessors[j];

      if (localAccessor == null)
        continue;
      i++;

      if (localAccessor.charLength > 0)
      {
        this.returnParamRowChars += localAccessor.charLength;
      }
      else
      {
        this.returnParamRowBytes += localAccessor.byteLength;
      }

    }

    if (this.isAutoGeneratedKey)
    {
      this.numReturnParams = i;
    }
    else
    {
      if (this.numReturnParams <= 0) {
        this.numReturnParams = OraclePreparedStatement.getReturnParameterCount(this.sqlObject.getOriginalSql());
      }

      if (this.numReturnParams != i) {
        DatabaseError.throwSqlException(173);
      }

    }

    this.returnParamMeta[0] = this.numReturnParams;
    this.returnParamMeta[1] = this.returnParamRowBytes;
    this.returnParamMeta[2] = this.returnParamRowChars;
  }

  void allocateDmlReturnStorage()
  {
    if (this.rowsDmlReturned == 0) return;

    int i = this.returnParamRowBytes * this.rowsDmlReturned;
    int j = this.returnParamRowChars * this.rowsDmlReturned;
    int k = 2 * this.numReturnParams * this.rowsDmlReturned;

    this.returnParamBytes = new byte[i];
    this.returnParamChars = new char[j];
    this.returnParamIndicators = new short[k];

    for (int m = 0; m < this.numberOfBindPositions; m++)
    {
      Accessor localAccessor = this.returnParamAccessors[m];

      if ((localAccessor == null) || ((localAccessor.internalType != 111) && (localAccessor.internalType != 109)))
      {
        continue;
      }
      TypeAccessor localTypeAccessor = (TypeAccessor)localAccessor;
      if ((localTypeAccessor.pickledBytes != null) && (localTypeAccessor.pickledBytes.length >= this.rowsDmlReturned))
        continue;
      localTypeAccessor.pickledBytes = new byte[this.rowsDmlReturned][];
    }
  }

  void fetchDmlReturnParams()
    throws SQLException
  {
    DatabaseError.throwSqlException(23);
  }

  void setupReturnParamAccessors()
  {
    if (this.rowsDmlReturned == 0) return;

    int i = 0;
    int j = 0;
    int k = 0;
    int m = this.numReturnParams * this.rowsDmlReturned;

    for (int n = 0; n < this.numberOfBindPositions; n++)
    {
      Accessor localAccessor = this.returnParamAccessors[n];

      if (localAccessor == null)
        continue;
      if (localAccessor.charLength > 0)
      {
        localAccessor.rowSpaceChar = this.returnParamChars;
        localAccessor.columnIndex = j;
        j += this.rowsDmlReturned * localAccessor.charLength;
      }
      else
      {
        localAccessor.rowSpaceByte = this.returnParamBytes;
        localAccessor.columnIndex = i;
        i += this.rowsDmlReturned * localAccessor.byteLength;
      }

      localAccessor.rowSpaceIndicator = this.returnParamIndicators;
      localAccessor.indicatorIndex = k;
      k += this.rowsDmlReturned;
      localAccessor.lengthIndex = m;
      m += this.rowsDmlReturned;
    }
  }

  void registerReturnParameterInternal(int paramInt1, int paramInt2, int paramInt3, int paramInt4, short paramShort, String paramString)
    throws SQLException
  {
    if (this.returnParamAccessors == null) {
      this.returnParamAccessors = new Accessor[this.numberOfBindPositions];
    }
    if (this.returnParamMeta == null)
    {
      this.returnParamMeta = new int[3 + this.numberOfBindPositions * 3];
    }

    Accessor localAccessor = allocateAccessor(paramInt2, paramInt3, paramInt1 + 1, paramInt4, paramShort, paramString, true);

    localAccessor.isDMLReturnedParam = true;
    this.returnParamAccessors[paramInt1] = localAccessor;

    int i = localAccessor.charLength > 0 ? 1 : 0;

    this.returnParamMeta[(3 + paramInt1 * 3 + 0)] = localAccessor.defineType;

    this.returnParamMeta[(3 + paramInt1 * 3 + 1)] = (i != 0 ? 1 : 0);

    this.returnParamMeta[(3 + paramInt1 * 3 + 2)] = (i != 0 ? localAccessor.charLength : localAccessor.byteLength);
  }

  public void setAutoRefetch(boolean paramBoolean)
    throws SQLException
  {
    this.autoRefetch = paramBoolean;
  }

  public boolean getAutoRefetch()
    throws SQLException
  {
    return this.autoRefetch;
  }

  /** @deprecated */
  public synchronized int creationState()
  {
    return this.creationState;
  }

  public boolean isColumnSetNull(int paramInt)
  {
    return this.columnSetNull;
  }

  public boolean isNCHAR(int paramInt)
    throws SQLException
  {
    if (!this.described) {
      describe();
    }
    int i = paramInt - 1;
    if ((i < 0) || (i >= this.numberOfDefinePositions)) {
      DatabaseError.throwSqlException(3);
    }
    int j = this.accessors[i].formOfUse == 2 ? 1 : 0;

    return j;
  }

  void addChild(OracleStatement paramOracleStatement)
  {
    paramOracleStatement.nextChild = this.children;
    this.children = paramOracleStatement;
  }

  public boolean getMoreResults(int paramInt)
    throws SQLException
  {
    DatabaseError.throwUnsupportedFeatureSqlException();

    return false;
  }

  public ResultSet getGeneratedKeys()
    throws SQLException
  {
    if (this.closed) {
      DatabaseError.throwSqlException(9);
    }
    if (!this.isAutoGeneratedKey) {
      DatabaseError.throwSqlException(90);
    }
    if ((this.returnParamAccessors == null) || (this.numReturnParams == 0)) {
      DatabaseError.throwSqlException(144);
    }
    if (this.returnResultSet == null)
    {
      this.returnResultSet = new OracleReturnResultSet(this);
    }

    return this.returnResultSet;
  }

  public int executeUpdate(String paramString, int paramInt)
    throws SQLException
  {
    if ((paramInt == 2) || (!AutoKeyInfo.isInsertSqlStmt(paramString)))
    {
      return executeUpdate(paramString);
    }
    if (paramInt != 1) {
      DatabaseError.throwSqlException(68);
    }
    synchronized (this.connection)
    {
      synchronized (this)
      {
        this.isAutoGeneratedKey = true;
        this.autoKeyInfo = new AutoKeyInfo(paramString);
        String str = this.autoKeyInfo.getNewSql();
        this.numberOfBindPositions = 1;

        autoKeyRegisterReturnParams();

        processDmlReturningBind();

        return executeUpdateInternal(str);
      }
    }
  }

  public int executeUpdate(String paramString, int[] paramArrayOfInt)
    throws SQLException
  {
    if (!AutoKeyInfo.isInsertSqlStmt(paramString)) return executeUpdate(paramString);

    if ((paramArrayOfInt == null) || (paramArrayOfInt.length == 0)) {
      DatabaseError.throwSqlException(68);
    }
    synchronized (this.connection)
    {
      synchronized (this)
      {
        this.isAutoGeneratedKey = true;
        this.autoKeyInfo = new AutoKeyInfo(paramString, paramArrayOfInt);

        this.connection.doDescribeTable(this.autoKeyInfo);

        String str = this.autoKeyInfo.getNewSql();
        this.numberOfBindPositions = paramArrayOfInt.length;

        autoKeyRegisterReturnParams();

        processDmlReturningBind();

        return executeUpdateInternal(str);
      }
    }
  }

  public int executeUpdate(String paramString, String[] paramArrayOfString)
    throws SQLException
  {
    if (!AutoKeyInfo.isInsertSqlStmt(paramString)) return executeUpdate(paramString);

    if ((paramArrayOfString == null) || (paramArrayOfString.length == 0)) {
      DatabaseError.throwSqlException(68);
    }
    synchronized (this.connection)
    {
      synchronized (this)
      {
        this.isAutoGeneratedKey = true;
        this.autoKeyInfo = new AutoKeyInfo(paramString, paramArrayOfString);

        this.connection.doDescribeTable(this.autoKeyInfo);

        String str = this.autoKeyInfo.getNewSql();
        this.numberOfBindPositions = paramArrayOfString.length;

        autoKeyRegisterReturnParams();

        processDmlReturningBind();

        return executeUpdateInternal(str);
      }
    }
  }

  public boolean execute(String paramString, int paramInt)
    throws SQLException
  {
    if ((paramInt == 2) || (!AutoKeyInfo.isInsertSqlStmt(paramString)))
    {
      return execute(paramString);
    }
    if (paramInt != 1) {
      DatabaseError.throwSqlException(68);
    }
    synchronized (this.connection)
    {
      synchronized (this)
      {
        this.isAutoGeneratedKey = true;
        this.autoKeyInfo = new AutoKeyInfo(paramString);
        String str = this.autoKeyInfo.getNewSql();
        this.numberOfBindPositions = 1;

        autoKeyRegisterReturnParams();

        processDmlReturningBind();

        return executeInternal(str);
      }
    }
  }

  public boolean execute(String paramString, int[] paramArrayOfInt)
    throws SQLException
  {
    if (!AutoKeyInfo.isInsertSqlStmt(paramString)) return execute(paramString);

    if ((paramArrayOfInt == null) || (paramArrayOfInt.length == 0)) {
      DatabaseError.throwSqlException(68);
    }
    synchronized (this.connection)
    {
      synchronized (this)
      {
        this.isAutoGeneratedKey = true;
        this.autoKeyInfo = new AutoKeyInfo(paramString, paramArrayOfInt);

        this.connection.doDescribeTable(this.autoKeyInfo);

        String str = this.autoKeyInfo.getNewSql();
        this.numberOfBindPositions = paramArrayOfInt.length;

        autoKeyRegisterReturnParams();

        processDmlReturningBind();

        return executeInternal(str);
      }
    }
  }

  public boolean execute(String paramString, String[] paramArrayOfString)
    throws SQLException
  {
    if (!AutoKeyInfo.isInsertSqlStmt(paramString)) return execute(paramString);

    if ((paramArrayOfString == null) || (paramArrayOfString.length == 0)) {
      DatabaseError.throwSqlException(68);
    }
    synchronized (this.connection)
    {
      synchronized (this)
      {
        this.isAutoGeneratedKey = true;
        this.autoKeyInfo = new AutoKeyInfo(paramString, paramArrayOfString);

        this.connection.doDescribeTable(this.autoKeyInfo);

        String str = this.autoKeyInfo.getNewSql();
        this.numberOfBindPositions = paramArrayOfString.length;

        autoKeyRegisterReturnParams();

        processDmlReturningBind();

        return executeInternal(str);
      }
    }
  }

  public int getResultSetHoldability()
    throws SQLException
  {
    return 1;
  }

  public int getcacheState()
  {
    return this.cacheState;
  }

  public int getstatementType()
  {
    return this.statementType;
  }

  public boolean getserverCursor()
  {
    return this.serverCursor;
  }

  void initializeIndicatorSubRange()
  {
    this.bindIndicatorSubRange = 0;
  }

  private void autoKeyRegisterReturnParams()
    throws SQLException
  {
    initializeIndicatorSubRange();

    int i = this.bindIndicatorSubRange + 3 + this.numberOfBindPositions * 10;

    int j = i + 2 * this.numberOfBindPositions;

    this.bindIndicators = new short[j];

    int k = this.bindIndicatorSubRange;

    this.bindIndicators[(k + 0)] = (short)this.numberOfBindPositions;

    this.bindIndicators[(k + 1)] = 1;

    this.bindIndicators[(k + 2)] = 1;

    k += 3;

    short[] arrayOfShort = this.autoKeyInfo.tableFormOfUses;
    int[] arrayOfInt = this.autoKeyInfo.columnIndexes;

    for (int m = 0; m < this.numberOfBindPositions; m++)
    {
      this.bindIndicators[(k + 0)] = 994;

      short s = 0;

      if ((arrayOfShort != null) && (arrayOfInt != null))
      {
        if (arrayOfShort[(arrayOfInt[m] - 1)] == 2)
        {
          s = 2;
          this.bindIndicators[(k + 9)] = s;
        }

      }

      k += 10;

      checkTypeForAutoKey(this.autoKeyInfo.returnTypes[m]);

      String str = null;
      if (this.autoKeyInfo.returnTypes[m] == 111) {
        str = this.autoKeyInfo.tableTypeNames[(arrayOfInt[m] - 1)];
      }

      registerReturnParameterInternal(m, this.autoKeyInfo.returnTypes[m], this.autoKeyInfo.returnTypes[m], -1, s, str);
    }
  }

  private final void setNonAutoKey()
  {
    this.isAutoGeneratedKey = false;
    this.numberOfBindPositions = 0;
    this.bindIndicators = null;
  }

  void saveDefineBuffersIfRequired(char[] paramArrayOfChar, byte[] paramArrayOfByte, short[] paramArrayOfShort, boolean paramBoolean)
    throws SQLException
  {
  }

  final void checkTypeForAutoKey(int paramInt)
    throws SQLException
  {
    if (paramInt == 109)
      DatabaseError.throwSqlException(5);
  }

  void addToTempLobsToFree(CLOB paramCLOB)
  {
    if (this.tempClobsToFree == null)
      this.tempClobsToFree = new ArrayList();
    this.tempClobsToFree.add(paramCLOB);
  }

  void addToTempLobsToFree(BLOB paramBLOB)
  {
    if (this.tempBlobsToFree == null)
      this.tempBlobsToFree = new ArrayList();
    this.tempBlobsToFree.add(paramBLOB);
  }

  void addToOldTempLobsToFree(CLOB paramCLOB)
  {
    if (this.oldTempClobsToFree == null)
      this.oldTempClobsToFree = new ArrayList();
    this.oldTempClobsToFree.add(paramCLOB);
  }

  void addToOldTempLobsToFree(BLOB paramBLOB)
  {
    if (this.oldTempBlobsToFree == null)
      this.oldTempBlobsToFree = new ArrayList();
    this.oldTempBlobsToFree.add(paramBLOB);
  }

  void cleanAllTempLobs()
  {
    cleanTempClobs(this.tempClobsToFree);
    this.tempClobsToFree = null;
    cleanTempBlobs(this.tempBlobsToFree);
    this.tempBlobsToFree = null;
    cleanTempClobs(this.oldTempClobsToFree);
    this.oldTempClobsToFree = null;
    cleanTempBlobs(this.oldTempBlobsToFree);
    this.oldTempBlobsToFree = null;
  }

  void cleanOldTempLobs()
  {
    cleanTempClobs(this.oldTempClobsToFree);
    cleanTempBlobs(this.oldTempBlobsToFree);
    this.oldTempClobsToFree = this.tempClobsToFree;
    this.tempClobsToFree = null;
    this.oldTempBlobsToFree = this.tempBlobsToFree;
    this.tempBlobsToFree = null;
  }

  void cleanTempClobs(ArrayList paramArrayList)
  {
    if (paramArrayList != null)
    {
      Iterator localIterator = paramArrayList.iterator();

      while (localIterator.hasNext())
      {
        try
        {
          ((CLOB)localIterator.next()).freeTemporary();
        }
        catch (SQLException localSQLException)
        {
        }
      }
    }
  }

  void cleanTempBlobs(ArrayList paramArrayList)
  {
    if (paramArrayList != null)
    {
      Iterator localIterator = paramArrayList.iterator();

      while (localIterator.hasNext())
      {
        try
        {
          ((BLOB)localIterator.next()).freeTemporary();
        }
        catch (SQLException localSQLException)
        {
        }
      }
    }
  }

  TimeZone getDefaultTimeZone()
  {
    if (this.defaultTZ == null) {
      this.defaultTZ = TimeZone.getDefault();
    }
    return this.defaultTZ;
  }
}

/* Location:           D:\oracle\product\10.2.0\client_1\jdbc\lib\ojdbc14.jar
 * Qualified Name:     oracle.jdbc.driver.OracleStatement
 * JD-Core Version:    0.6.0
 */